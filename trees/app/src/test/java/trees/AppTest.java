/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.Test;

import java.util.ArrayList;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {
    ///////////// Tests for code 17 ////////////
    // test if tree is empty // it will raise an exception
    @Test void breadthemptyTreeTest ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        try{
            biTree.breadthFirst(biTree.getRoot());
        }catch (Exception e )
        {
            System.err.println("tree is empty " );
        }
    }
    // test if tree has one node  one level (root)
    @Test void breadthemptyTreeTest1 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        ArrayList arr = new ArrayList();
        arr.add(15);
        assertEquals(biTree.breadthFirst(biTree.getRoot()),arr);
    }
    // test if tree has 2 levels
    @Test void breadthemptyTreeTest2 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().setRight( new Node<>(5));
        ArrayList arr = new ArrayList();
        arr.add(15);
        arr.add(7);
        arr.add(5);
        assertEquals(biTree.breadthFirst(biTree.getRoot()),arr);
    }
    // test if tree has multiple levels  levels
    @Test void breadthemptyTreeTest3 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(2));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().setRight( new Node<>(5));
        biTree.getRoot().getLeft().setLeft(new Node<>(2));
        biTree.getRoot().getLeft().setRight(new Node<>(6));
        biTree.getRoot().getRight().setRight(new Node<>(9));

        biTree.getRoot().getLeft().getRight().setLeft(new Node<>(5));
        biTree.getRoot().getLeft().getRight().setRight(new Node<>(11));
        biTree.getRoot().getRight().getRight().setLeft(new Node<>(4));
        ArrayList arr = new ArrayList();
        arr.add(2);
        arr.add(7);
        arr.add(5);
        arr.add(2);
        arr.add(6);arr.add(9);arr.add(5);arr.add(11);arr.add(4);
        assertEquals(biTree.breadthFirst(biTree.getRoot()),arr);
    }
    // test if all nodes has just left node (no right node)
    @Test void breadthemptyTreeTest4 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().getLeft().setLeft( new Node<>(5));
        biTree.getRoot().getLeft().getLeft().setLeft(new Node<>(3));
        ArrayList arr = new ArrayList();
        arr.add(15);
        arr.add(7);
        arr.add(5);
        arr.add(3);
        assertEquals(biTree.breadthFirst(biTree.getRoot()),arr);
    }
    // test if all nodes has just right node (no left node)
    @Test void breadthemptyTreeTest5 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setRight(new Node<>(7));
        biTree.getRoot().getRight().setRight( new Node<>(5));
        biTree.getRoot().getRight().getRight().setRight(new Node<>(3));
        ArrayList arr = new ArrayList();
        arr.add(15);
        arr.add(7);
        arr.add(5);
        arr.add(3);
        assertEquals(biTree.breadthFirst(biTree.getRoot()),arr);
    }




        ////////////Tests for code 16 ////////////

    // test if tree is empty // it will raise an exception
        @Test void emptyTreeTest1 ()
        {
            BinaryTree <Integer> biTree = new BinaryTree<>();
            try{
                biTree.maximumValue();
            }catch (Exception e )
            {
                System.err.println("tree is empty " );
            }
        }
    // test if tree has one value (root) // returns the root
    @Test void oneValueTreeTest1 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(52));
        assertEquals(biTree.maximumValue(),52);
    }
    // test if tree has root and left of(root)// root is not max
    @Test void twoValueTreeTest ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(52));
        assertEquals(biTree.maximumValue(),52);
    }
    // test if tree has root and left of(root)// root is max
    @Test void twoValueTreeTest4 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(70));
        biTree.getRoot().setLeft(new Node<>(2));
        assertEquals(biTree.maximumValue(),70);
    }
    // test if tree has root and right of(root) // root is not max
    @Test void twoValueTreeTest2 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(2));
        biTree.getRoot().setRight(new Node<>(50));
        assertEquals(biTree.maximumValue(),50);
    }
    // test if tree has root and right of(root) // root is max
    @Test void twoValueTreeTest3 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(50));
        biTree.getRoot().setRight(new Node<>(2));
        assertEquals(biTree.maximumValue(),50);
    }
    // if tree has many nodes
    @Test void twoValueTreeTest5 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(2));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().setRight( new Node<>(5));
        biTree.getRoot().getLeft().setLeft(new Node<>(2));
        biTree.getRoot().getLeft().setRight(new Node<>(6));
        biTree.getRoot().getRight().setRight(new Node<>(9));
        assertEquals(biTree.maximumValue(),9);
    }
    // if tree has many nodes // max is somewhere in the tree // not leaf node
    @Test void twoValueTreeTest6 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(2));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().setRight( new Node<>(100));
        biTree.getRoot().getLeft().setLeft(new Node<>(2));
        biTree.getRoot().getLeft().setRight(new Node<>(6));
        biTree.getRoot().getRight().setRight(new Node<>(9));
        assertEquals(biTree.maximumValue(),100);
    }
    // if tree has many nodes // max is somewhere in the tree // max is leaf node
    @Test void twoValueTreeTest7 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(2));
        biTree.getRoot().setLeft(new Node<>(7));
        biTree.getRoot().setRight( new Node<>(5));
        biTree.getRoot().getLeft().setLeft(new Node<>(2));
        biTree.getRoot().getLeft().setRight(new Node<>(6));
        biTree.getRoot().getRight().setRight(new Node<>(50));
        assertEquals(biTree.maximumValue(),50);
    }
    //test Can successfully instantiate an empty tree
    @Test void emptyTreeTest ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        assertEquals(biTree.getRoot(),null);
    }
    //Can successfully instantiate a tree with a single root node
    @Test void rootTreeTest2 ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(5));
        assertEquals(biTree.getRoot().getValue(),5);
    }
    //For a Binary Search Tree, can successfully add a left child and right child properly to a node
    @Test void binarySearchAddLeftRightTest ()
    {
        BinarySearchTree<Integer> binSearchT = new BinarySearchTree();
        binSearchT.add(60);
        binSearchT.add(40);
        binSearchT.add(80);
        assertEquals(binSearchT.toString(),"BinarySearchTree{root=Node{value=60, left=Node{value=40, left=null, right=null}, right=Node{value=80, left=null, right=null}}}");
    }
    //Can successfully return a collection from a preorder traversal
    @Test void returncollectionPreOrderTest ()
    {
    BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(30));
        biTree.getRoot().setRight( new Node<>(25));
        biTree.getRoot().getLeft().setLeft(new Node<>(35));
        biTree.getRoot().getLeft().setRight(new Node<>(40));
        ArrayList arr = new ArrayList();
        arr.add(15);
        arr.add(30);
        arr.add(35);
        arr.add(40);
        arr.add(25);
//        assertEquals(biTree.preOrder(biTree.getRoot()), new int[]{15, 30, 35, 40, 25});
//        int []arr2 = {15,30,35,40,25};
//        assertTrue(biTree.preOrder(biTree.getRoot()),arr2));
        assertEquals(biTree.preOrder(biTree.getRoot()),arr);
    }
    //Can successfully return a collection from an inorder traversal
    @Test void returncollectionInOrderTest ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(30));
        biTree.getRoot().setRight( new Node<>(25));
        biTree.getRoot().getLeft().setLeft(new Node<>(35));
        biTree.getRoot().getLeft().setRight(new Node<>(40));
        ArrayList arr = new ArrayList();
        arr.add(35);
        arr.add(30);
        arr.add(40);
        arr.add(15);
        arr.add(25);

        assertEquals(biTree.inOrder(biTree.getRoot()),arr);
    }
    //Can successfully return a collection from a postorder traversal
    @Test void returncollectionPostOrderTest ()
    {
        BinaryTree <Integer> biTree = new BinaryTree<>();
        biTree.setRoot(new Node<>(15));
        biTree.getRoot().setLeft(new Node<>(30));
        biTree.getRoot().setRight( new Node<>(25));
        biTree.getRoot().getLeft().setLeft(new Node<>(35));
        biTree.getRoot().getLeft().setRight(new Node<>(40));
        ArrayList arr = new ArrayList();
        arr.add(35);
        arr.add(40);
        arr.add(30);
        arr.add(25);
        arr.add(15);
        assertEquals(biTree.postOrder(biTree.getRoot()),arr);
    }
    // contains methode return true if value is exsist
    @Test void containsTest ()
    {
        BinarySearchTree<Integer> binSearchT = new BinarySearchTree();
        binSearchT.add(50);
        binSearchT.add(30);
        binSearchT.add(40);
        binSearchT.add(20);
        binSearchT.add(60);
        assertTrue(binSearchT.contains(50));
        assertTrue(binSearchT.contains(30));
        assertTrue(binSearchT.contains(40));
        assertTrue(binSearchT.contains(20));
        assertTrue(binSearchT.contains(60));
    }
    // contains methode return false if value is not exsist
    @Test void containsTest2 ()
    {
        BinarySearchTree<Integer> binSearchT = new BinarySearchTree();
        binSearchT.add(50);
        binSearchT.add(30);
        binSearchT.add(40);
        binSearchT.add(20);
        binSearchT.add(60);
        assertEquals(binSearchT.contains(55),false);
        assertEquals(binSearchT.contains(39),false);
        assertEquals(binSearchT.contains(42),false);
        assertEquals(binSearchT.contains(26),false);
        assertEquals(binSearchT.contains(67),false);

    }
}
